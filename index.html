<html lang="en">
<head>
	<title>-OD</title>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
	body {
		font-family: Monospace;
		margin: 0px;
		overflow: hidden;
	}
	</style>
</head>
<body>

	<script src="three.min.js"></script>
	<script>

	var camera, scene, renderer;
	var sphere;
	var cones = [];
	var coneCount = 50;
	var player;
	var keys = [];
	var r = 0.98;

	init();
	animate();

	function init() {

		scene = new THREE.Scene();

		camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 1000 );
		camera.position.z = 0.98;

		var sphereGeom = new THREE.SphereGeometry(1, 30	 ,30);
		sphere = new THREE.Mesh(sphereGeom, new THREE.MeshBasicMaterial( { color: 0x00ffaa, wireframe: true, side: THREE.BackSide} ));
		scene.add(sphere);

		var coneGeom = new THREE.SphereGeometry(0.05, 6, 6);//CylinderGeometry(0, 0.1, 0.3);
		//coneGeom.applyMatrix( new THREE.Matrix4().makeRotationFromEuler( new THREE.Euler( Math.PI / 2, Math.PI, 0 ) ) )

		for(var i = 0; i < coneCount; i++){
			var cone = new THREE.Mesh(coneGeom, new THREE.MeshBasicMaterial( { color: 0xaaff00, wireframe: true,side: THREE.BackSide } ));
			
			var v = sphericalToCartesian(randomSpherePoint().sub(new THREE.Vector3(0.05,0,0)));
			badplace = true;
			while(!badplace){

				for(var k = 0; k < cones.length; k++){
					badplace = false;
					if(v.distanceTo(cones[k].position) < 0.1){
						badplace = true;
						v = sphericalToCartesian(randomSpherePoint().sub(new THREE.Vector3(0.05,0,0)));
						break;
					}
						

				}

			}
			scene.add(cone)
			cone.position.set(v.x, v.y, v.z);
			cone.lookAt(sphere.position);
			cones.push(cone);
		}
		console.log(cones)
		renderer = new THREE.WebGLRenderer();
		renderer.setClearColor( 0xf0f0f0 );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );

		document.addEventListener("keydown", keyDown, false);
		document.addEventListener("keyup", keyUp, false);
		

	}


	function keyDown(e){
		if (e.keyCode == 65 && keys.indexOf(65) == -1)
			keys.push(65);

		if (e.keyCode == 68 && keys.indexOf(68) == -1)
			keys.push(68);

		if (e.keyCode == 83 && keys.indexOf(83) == -1)
			keys.push(83);

		if (e.keyCode == 87 && keys.indexOf(87) == -1)
			keys.push(87);	
	}

	function keyUp(e){
		if (e.keyCode == 65)
			keys.pop(65);

		if (e.keyCode == 68)
			keys.pop(68);

		if (e.keyCode == 83)
			keys.pop(83);

		if (e.keyCode == 87)
			keys.pop(87);	
	}

	function sphericalToCartesian(v){
		var r = v.x;
		var theta = v.y;
		var phi = v.z;
		var x = r * Math.cos(theta) * Math.sin(phi);
		var y = r * Math.sin(theta) * Math.sin(phi);
		var z = r * Math.cos(phi);
		return(new THREE.Vector3(x, y, z));
	}


	function randomSpherePoint(){
		var theta = (Math.random() * 2 * Math.PI) - Math.PI;
		var phi = 2 * Math.asin(Math.sqrt(Math.random()));
		return(new THREE.Vector3(1, theta, phi))
	}


	function animate() {

		requestAnimationFrame( animate );
		
		if (keys.indexOf(65) != -1)
			camera.quaternion.multiply(new THREE.Quaternion(0, Math.sin(-0.01), 0, Math.cos(-0.01)));
		if (keys.indexOf(68) != -1)
			camera.quaternion.multiply(new THREE.Quaternion(0, Math.sin(0.01), 0, Math.cos(0.01)));
		if (keys.indexOf(83) != -1)
			camera.quaternion.multiply(new THREE.Quaternion(Math.sin(-0.01), 0, 0, Math.cos(-0.01)));
		if (keys.indexOf(87) != -1)
			camera.quaternion.multiply(new THREE.Quaternion(Math.sin(0.01), 0, 0, Math.cos(0.01)));

		var qx = camera.quaternion.x;
		var qy = camera.quaternion.y;
		var qz = camera.quaternion.z;
		var qw = camera.quaternion.w;
		camera.position.x = 2 * (qy * qw + qz * qx) * r;
		camera.position.y = 2 * (qz * qy - qw * qx) *r;
		camera.position.z = ((qz * qz + qw * qw) - (qx * qx + qy * qy)) *r;
		render();

	}

	function render() {

		renderer.render( scene, camera );

	}

	</script>

</body>
</html>
