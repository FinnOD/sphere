<html lang="en">
<head>
	<title>-OD</title>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
	body {
		font-family: Monospace;
		margin: 0px;
		overflow: hidden;
	}
	</style>
</head>
<body>

	<script src="three.min.js"></script>
	<script>

	var camera, scene, renderer;
	var sphere;

	var scale = 1;
	var cones = [];
	var clearings = [];
	var coneCount = Math.round(250*scale*Math.log(scale*4)); //330 max
	var clearingCount = Math.round(3*scale); 
	var player;
	var keys = [];
	var r = 1;

	init();
	animate();

	function init() {

		scene = new THREE.Scene();

		camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 1000 );
		camera.position.z = r;

		var sphereGeom = new THREE.SphereGeometry(1, 30	 ,30);
		sphere = new THREE.Mesh(sphereGeom, new THREE.MeshBasicMaterial( { color: 0x00ffaa, wireframe: true}));//, side: THREE.BackSide} ));
		scene.add(sphere);

		var coneGeom = new THREE.SphereGeometry(0.05/scale, 5, 5);

		for(var i = 0; i < coneCount; i++){
			var cone = new THREE.Mesh(coneGeom, new THREE.MeshBasicMaterial( { color: 0xaaff00, wireframe: true,side: THREE.BackSide } ));
			
			var v = sphericalToCartesian(randomSpherePoint().sub(new THREE.Vector3(0.05/scale,0,0)));
			
			badplace = false;
			while(!badplace){
				badplace = true;
				for(var k = 0; k < cones.length; k++){
					if(v.distanceTo(cones[k].position) < 0.15/scale){
						badplace = false;
						v = sphericalToCartesian(randomSpherePoint().sub(new THREE.Vector3(0.05/scale,0,0)));
						break;
					}
				}
			}
			scene.add(cone)
			cone.position.set(v.x, v.y, v.z);
			cones.push(cone);
		}
		
		for(var i = 0; i < clearingCount; i++){
			var v = sphericalToCartesian(randomSpherePoint());
			clearings.push(v);

			var sphereGeom = new THREE.SphereGeometry(0.2/scale, 12,12);
			sphre = new THREE.Mesh(sphereGeom, new THREE.MeshBasicMaterial( { color: 0xff0000, wireframe: true} ));
			v.add(new THREE.Vector3(0, 0 , 0.05/scale));
			sphre.position.set(v.x, v.y, v.z)
			scene.add(sphre)

			for(var k = 0; k < coneCount; k++){
				
				if(cones[k].position.distanceTo(v) < 0.25/scale){
					scene.remove(cones[k]);
					
					cones.pop(cones[k]);
					coneCount--;
				}
			}
		}

		renderer = new THREE.WebGLRenderer();
		renderer.setClearColor( 0xf0f0f0 );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );

		document.addEventListener("keydown", keyDown, false);
		document.addEventListener("keyup", keyUp, false);
		window.addEventListener( 'resize', onWindowResize, false )
		

	}

	function onWindowResize(){

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}

	function keyDown(e){
		if (e.keyCode == 65 && keys.indexOf(65) == -1)
			keys.push(65);

		if (e.keyCode == 68 && keys.indexOf(68) == -1)
			keys.push(68);

		if (e.keyCode == 83 && keys.indexOf(83) == -1)
			keys.push(83);

		if (e.keyCode == 87 && keys.indexOf(87) == -1)
			keys.push(87);	
	}

	function keyUp(e){
		if (e.keyCode == 65)
			keys.pop(65);

		if (e.keyCode == 68)
			keys.pop(68);

		if (e.keyCode == 83)
			keys.pop(83);

		if (e.keyCode == 87)
			keys.pop(87);	
	}

	function sphericalToCartesian(v){
		var r = v.x;
		var theta = v.y;
		var phi = v.z;
		var x = r * Math.cos(theta) * Math.sin(phi);
		var y = r * Math.sin(theta) * Math.sin(phi);
		var z = r * Math.cos(phi);
		return(new THREE.Vector3(x, y, z));
	}


	function randomSpherePoint(){
		var theta = (Math.random() * 2 * Math.PI) - Math.PI;
		var phi = 2 * Math.asin(Math.sqrt(Math.random()));
		return(new THREE.Vector3(1, theta, phi))
	}


	function animate() {

		requestAnimationFrame( animate );
		
		if (keys.indexOf(65) != -1)
			camera.quaternion.multiply(new THREE.Quaternion(0, Math.sin(-0.01), 0, Math.cos(-0.01)));
		if (keys.indexOf(68) != -1)
			camera.quaternion.multiply(new THREE.Quaternion(0, Math.sin(0.01), 0, Math.cos(0.01)));
		if (keys.indexOf(83) != -1)
			camera.quaternion.multiply(new THREE.Quaternion(Math.sin(-0.01), 0, 0, Math.cos(-0.01)));
		if (keys.indexOf(87) != -1)
			camera.quaternion.multiply(new THREE.Quaternion(Math.sin(0.01), 0, 0, Math.cos(0.01)));

		var qx = camera.quaternion.x;
		var qy = camera.quaternion.y;
		var qz = camera.quaternion.z;
		var qw = camera.quaternion.w;
		camera.position.x = 2 * (qy * qw + qz * qx) * r;
		camera.position.y = 2 * (qz * qy - qw * qx) *r;
		camera.position.z = ((qz * qz + qw * qw) - (qx * qx + qy * qy)) *r;
		render();

	}

	function render() {

		renderer.render( scene, camera );

	}

	</script>

</body>
</html>
